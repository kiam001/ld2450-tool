<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LD2450 Architect v14.0</title>
    <style>
        :root { --primary: #007bff; --bg: #f4f4f9; --panel: #ffffff; --border: #ccc; --success: #28a745; }
        body { font-family: -apple-system, system-ui, sans-serif; display: flex; height: 100vh; margin: 0; background: var(--bg); color: #333; overflow: hidden; }
        
        .sidebar { width: 400px; display: flex; flex-direction: column; background: var(--panel); border-right: 1px solid var(--border); box-shadow: 2px 0 10px rgba(0,0,0,0.05); }
        .main { flex-grow: 1; display: flex; justify-content: center; align-items: center; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .output-panel { width: 450px; display: flex; flex-direction: column; background: var(--panel); border-left: 1px solid var(--border); }

        .header { padding: 15px; background: #fff; border-bottom: 1px solid var(--border); }
        .header h2 { margin: 0; font-size: 1.1rem; color: var(--primary); }
        
        .section { padding: 15px; border-bottom: 1px solid var(--border); overflow-y: auto; flex-grow: 1;}
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; font-size: 0.75rem; font-weight: 700; margin-bottom: 4px; color: #555; }
        .input-group input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }

        .live-box { background: #e8f5e9; border: 1px solid #c8e6c9; border-radius: 4px; padding: 10px; margin-bottom: 10px; }
        .status-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: #999; margin-right: 5px; vertical-align: middle;}
        .status-dot.active { background: #28a745; box-shadow: 0 0 5px #28a745; }

        .zone-list { min-height: 100px; padding: 10px; background: #fafafa; border: 1px solid #eee; margin-bottom: 10px;}
        .zone-item { background: #fff; border: 1px solid #ddd; padding: 8px; margin-bottom: 5px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px;}
        .zone-item.active { background: #e3f2fd; border-color: var(--primary); }
        .zone-color { width: 12px; height: 12px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.1); }
        .zone-name { flex-grow: 1; border: none; background: transparent; font-size: 0.9rem;}

        .actions { padding: 10px; border-top: 1px solid var(--border); display: grid; grid-template-columns: 1fr 1fr; gap: 8px; background: #fff;}
        button { padding: 8px; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 0.85rem; background: #e9ecef;}
        .btn-primary { background: var(--primary); color: white; }
        .btn-success { background: var(--success); color: white; }

        .canvas-wrapper { background: white; border: 2px solid #333; box-shadow: 0 10px 30px rgba(0,0,0,0.15); position: relative; }
        #canvas { display: block; cursor: crosshair; }
        .overlay-info { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 5px; border-radius: 4px; font-size: 0.75rem; border: 1px solid #ddd; pointer-events: none;}

        .output-section { flex: 1; display: flex; flex-direction: column; padding: 10px; border-bottom: 1px solid #eee; overflow: hidden;}
        .output-section h3 { margin: 0 0 5px 0; font-size: 0.85rem; display: flex; justify-content: space-between; }
        textarea { flex-grow: 1; font-family: monospace; font-size: 11px; padding: 8px; border: 1px solid #ccc; background: #f8f8f8; resize: none; white-space: pre; overflow: auto;}
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="header">
            <h2>LD2450 Architect v14.0</h2>
            <div style="font-size: 0.75rem; color: #666;">External URL Support</div>
        </div>

        <div class="section">
            <div class="live-box">
                <div class="input-group">
                    <label>Home Assistant URL (z.B. http://192.168.1.50:8123)</label>
                    <input type="text" id="haUrl" placeholder="http://homeassistant.local:8123">
                </div>
                <div class="input-group">
                    <label>Langzeit-Zugangstoken</label>
                    <input type="password" id="haToken">
                </div>
                <button class="btn-success" style="width:100%" onclick="startLive()">
                    <span class="status-dot" id="statusDot"></span> Verbinden
                </button>
                <div id="debugMsg" style="font-size: 0.7rem; color: #666; margin-top:5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
            </div>

            <div class="input-group">
                <label>ESPHome Gerätename</label>
                <input type="text" id="devName" value="ld2450-zimmer" oninput="updateAll()">
            </div>
            <div class="input-group">
                <label>Friendly Name (Titel)</label>
                <input type="text" id="friendlyName" value="LD2450 Zimmer" oninput="updateAll()">
            </div>

            <div class="zone-list" id="zoneList"></div>
        </div>

        <div class="actions">
            <button class="btn-primary" onclick="addZone()">+ Neue Zone</button>
            <button onclick="clearActiveZone()">Leeren</button>
            <button onclick="document.getElementById('fileInput').click()">Laden</button>
            <button onclick="exportConfig()">Speichern</button>
        </div>
        <input type="file" id="fileInput" style="display: none" accept=".json" onchange="importConfig(this)">
    </div>

    <div class="main">
        <div class="canvas-wrapper">
            <canvas id="canvas" width="600" height="600"></canvas>
            <div class="overlay-info">
                Links: Punkt/Move | Rechts: Löschen<br>
                <span style="color:blue">● T1</span> <span style="color:red">● T2</span> <span style="color:green">● T3</span>
            </div>
        </div>
    </div>

    <div class="output-panel">
        <div class="output-section">
            <h3>1. Firmware (ESPHome) <button onclick="copyToClip('outFirmware')">Kopieren</button></h3>
            <textarea id="outFirmware" readonly></textarea>
        </div>
        <div class="output-section">
            <h3>2. Karte (Plotly) <button onclick="copyToClip('outCard')">Kopieren</button></h3>
            <textarea id="outCard" readonly></textarea>
        </div>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Config
    const W = 600, H = 600;
    const SENSOR_X = 300, SENSOR_Y = 600;
    const METER_TO_PX = 100; 
    const SNAP_DIST = 15;

    // State
    let config = {
        name: "ld2450-zimmer",
        friendly: "LD2450 Zimmer",
        zones: [ { id: 1, name: "Zone 1", color: "#007bff", points: [] } ]
    };
    
    let activeZoneIdx = 0;
    let dragInfo = { active: false, pointIdx: -1 };
    let liveTargets = { t1: {x:0,y:0,a:false}, t2: {x:0,y:0,a:false}, t3: {x:0,y:0,a:false} };
    let liveInterval = null;

    // Coverage Polygon
    const covX = [0, 520, 450, 400, 300, 200, 100, 0, -100, -200, -300, -400, -450, -520, 0];
    const covY = [0, 300, 396, 447, 519, 565, 591, 600, 591, 565, 519, 447, 396, 300, 0];

    function init() {
        if(localStorage.getItem('ha_token')) document.getElementById('haToken').value = localStorage.getItem('ha_token');
        if(localStorage.getItem('ha_url')) document.getElementById('haUrl').value = localStorage.getItem('ha_url');
        
        renderUI(); draw(); updateAll();
        
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
    }

    // --- DRAWING ---
    function draw() {
        ctx.clearRect(0, 0, W, H);
        drawGrid();
        drawCoverage();
        config.zones.forEach((zone, idx) => { drawPoly(zone, idx === activeZoneIdx); });
        drawLiveTargets();
    }

    function drawGrid() {
        ctx.strokeStyle = '#f8f8f8'; ctx.lineWidth = 1;
        for(let x=0; x<=W; x+=50) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
        for(let y=0; y<=H; y+=50) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(SENSOR_X, 0); ctx.lineTo(SENSOR_X, H); ctx.stroke();
        ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(SENSOR_X, SENSOR_Y, 6, 0, Math.PI*2); ctx.fill();
    }

    function drawCoverage() {
        ctx.beginPath();
        for(let i=0; i<covX.length; i++) {
            let px = covX[i] + SENSOR_X;
            let py = SENSOR_Y - covY[i];
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = "rgba(168, 216, 234, 0.2)"; ctx.fill();
        ctx.strokeStyle = "rgba(168, 216, 234, 0.6)"; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
    }

    function drawPoly(zone, isActive) {
        if(zone.points.length === 0) return;
        ctx.beginPath();
        ctx.moveTo(zone.points[0].x, zone.points[0].y);
        for(let i=1; i<zone.points.length; i++) ctx.lineTo(zone.points[i].x, zone.points[i].y);
        ctx.closePath();
        ctx.fillStyle = isActive ? hexToRgba(zone.color, 0.2) : 'rgba(200,200,200,0.1)';
        ctx.strokeStyle = isActive ? zone.color : '#ccc';
        ctx.lineWidth = isActive ? 2 : 1;
        ctx.fill(); ctx.stroke();
        if(isActive) {
            ctx.fillStyle = zone.color;
            zone.points.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill(); });
        }
    }

    function drawLiveTargets() {
        if (liveTargets.t1.a) drawTarget(liveTargets.t1, 'blue', 'T1');
        if (liveTargets.t2.a) drawTarget(liveTargets.t2, 'red', 'T2');
        if (liveTargets.t3.a) drawTarget(liveTargets.t3, 'green', 'T3');
    }

    function drawTarget(t, color, label) {
        let px = (t.x * 100) + SENSOR_X;
        let py = SENSOR_Y - (t.y * 100);
        if (!Number.isFinite(px) || !Number.isFinite(py)) return;
        let grad = ctx.createRadialGradient(px, py, 2, px, py, 15);
        grad.addColorStop(0, color); grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(px, py, 15, 0, 2*Math.PI); ctx.fill();
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*Math.PI); ctx.fill();
        ctx.fillStyle = '#333'; ctx.font = "bold 11px sans-serif"; ctx.fillText(label, px+8, py+3);
    }

    // --- INTERACTION ---
    function handleMouseDown(e) {
        const {x, y} = getMousePos(e);
        const zone = config.zones[activeZoneIdx];
        for(let i = zone.points.length - 1; i >= 0; i--) {
            const p = zone.points[i];
            if(Math.hypot(p.x - x, p.y - y) < SNAP_DIST) {
                if(e.button === 2) { zone.points.splice(i, 1); draw(); updateAll(); return; }
                dragInfo = { active: true, pointIdx: i }; return;
            }
        }
        if(e.button === 0) { zone.points.push({x, y}); draw(); updateAll(); }
    }
    function handleMouseMove(e) {
        if(dragInfo.active) {
            const {x, y} = getMousePos(e);
            const zone = config.zones[activeZoneIdx];
            let safeX = Math.max(0, Math.min(W, x)); let safeY = Math.max(0, Math.min(H, y));
            zone.points[dragInfo.pointIdx] = {x: safeX, y: safeY}; draw();
        }
    }
    function handleMouseUp() { if(dragInfo.active) { dragInfo.active = false; updateAll(); } }
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    // --- LIVE DATA ---
    async function startLive() {
        const urlRaw = document.getElementById('haUrl').value.trim();
        const token = document.getElementById('haToken').value.trim();
        const rawName = document.getElementById('devName').value.trim();
        
        if (!token || !urlRaw) { alert("URL und Token fehlen!"); return; }
        
        // Remove trailing slash
        const baseUrl = urlRaw.replace(/\/$/, "");
        
        localStorage.setItem('ha_token', token);
        localStorage.setItem('ha_url', baseUrl);
        
        const sensorId = rawName.replace(/-/g, '_').toLowerCase();

        document.getElementById('debugMsg').innerText = "Verbinde...";
        if (liveInterval) clearInterval(liveInterval);

        try {
            await fetchStates(baseUrl, token, sensorId);
            document.getElementById('statusDot').classList.add('active');
            document.getElementById('debugMsg').innerText = "Verbunden.";
            liveInterval = setInterval(() => fetchStates(baseUrl, token, sensorId), 1000);
        } catch (e) {
            document.getElementById('debugMsg').innerText = "Fehler: " + e.message;
        }
    }

    async function fetchStates(baseUrl, token, sensorId) {
        try {
            const response = await fetch(`${baseUrl}/api/states`, {
                headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
            });
            if (!response.ok) throw new Error("API Fehler (CORS?)");
            const data = await response.json();
            
            const t1_x = data.find(e => e.entity_id === `sensor.${sensorId}_t1_t1_xpos`);
            const t1_y = data.find(e => e.entity_id === `sensor.${sensorId}_t1_t1_ypos`);
            const t2_x = data.find(e => e.entity_id === `sensor.${sensorId}_target_2_t2_xpos`);
            const t2_y = data.find(e => e.entity_id === `sensor.${sensorId}_target_2_t2_ypos`);
            const t3_x = data.find(e => e.entity_id === `sensor.${sensorId}_target_3_t3_xpos`);
            const t3_y = data.find(e => e.entity_id === `sensor.${sensorId}_target_3_t3_ypos`);

            updateTargetData('t1', t1_x, t1_y);
            updateTargetData('t2', t2_x, t2_y);
            updateTargetData('t3', t3_x, t3_y);
            draw();
        } catch(e) {
            throw e;
        }
    }

    function updateTargetData(key, sx, sy) {
        if (sx && sy && sx.state !== 'unavailable' && sx.state !== 'unknown') {
            let valX = parseFloat(sx.state); let valY = parseFloat(sy.state);
            if (!isNaN(valX) && !isNaN(valY)) {
                liveTargets[key].x = valX; liveTargets[key].y = valY; liveTargets[key].a = true; return;
            }
        }
        liveTargets[key].a = false;
    }

    // --- UI & GENERATION ---
    function renderUI() {
        const list = document.getElementById('zoneList');
        list.innerHTML = "";
        config.zones.forEach((zone, idx) => {
            const el = document.createElement('div');
            el.className = `zone-item ${idx === activeZoneIdx ? 'active' : ''}`;
            el.onclick = () => { activeZoneIdx = idx; renderUI(); draw(); };
            el.innerHTML = `
                <div class="zone-color" style="background:${zone.color}"></div>
                <input type="text" class="zone-name" value="${zone.name}" onchange="renameZone(${idx}, this.value)" onclick="event.stopPropagation()">
                <button onclick="deleteZone(${idx}); event.stopPropagation()" style="color:red; background:none; border:none; cursor:pointer;">X</button>
            `;
            list.appendChild(el);
        });
        document.getElementById('devName').value = config.name;
        document.getElementById('friendlyName').value = config.friendly;
    }

    function addZone() {
        const colors = ['#007bff', '#28a745', '#dc3545', '#fd7e14', '#6f42c1'];
        config.zones.push({ id: Date.now(), name: `Zone${config.zones.length + 1}`, color: colors[config.zones.length % colors.length], points: [] });
        activeZoneIdx = config.zones.length - 1; renderUI(); draw();
    }
    function deleteZone(idx) { if(confirm("Löschen?")) { config.zones.splice(idx, 1); if(config.zones.length === 0) addZone(); activeZoneIdx = 0; renderUI(); draw(); updateAll(); } }
    function renameZone(idx, val) { config.zones[idx].name = val; updateAll(); }
    function clearActiveZone() { config.zones[activeZoneIdx].points = []; draw(); updateAll(); }
    function updateAll() {
        config.name = document.getElementById('devName').value;
        config.friendly = document.getElementById('friendlyName').value;
        document.getElementById('outFirmware').value = generateFirmware();
        document.getElementById('outCard').value = generateCard();
    }

    function pxToM(px, py) { return { x: ((px - SENSOR_X) / METER_TO_PX).toFixed(2), y: ((SENSOR_Y - py) / METER_TO_PX).toFixed(2) }; }

    // --- FULL FIRMWARE GENERATOR ---
    function generateFirmware() {
        let yaml = `esphome:
  name: "${config.name}"
  friendly_name: "${config.friendly}"

esp8266:
  board: d1_mini

# Enable logging
logger:
  baud_rate: 0

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${config.friendly.replace(/ /g,'-')}-Fail"
    password: !secret ap_wifi_password

captive_portal:

external_components:
- source: github://ShaunPCcom/ESPHome-HLK-LD2450

uart:
  id: uart_bus
  rx_pin: 
    number: GPIO3
    mode:
      input: true
      pullup: true
  tx_pin: 
    number: GPIO1
    mode:
      input: true
      pullup: true
  baud_rate: 256000
  parity: NONE
  stop_bits: 1
  data_bits: 8

LD2450:
  uart_id: uart_bus
  flip_x_axis: false
  fast_off_detection: false
  max_detection_tilt_angle:
    name: "Max Tilt Angle"
    initial_value: 90°
  min_detection_tilt_angle:
    name: "Min Tilt Angle"
    initial_value: -90°
  max_detection_distance:
    name: "Max Distance"
    initial_value: 6m
  
  restart_button:
    name: "Restart Sensor"
  factory_reset_button:
    name: "Factory Reset Sensor"

  tracking_mode_switch:
    name: "Multiple Target Tracking"
  bluetooth_switch:
    name: "Sensor Bluetooth"

  baud_rate_select:
    name: "Sensor Baud Rate"

  occupancy:
    name: Occupancy
  target_count:
    name: Target Count

  targets:
    - target:
        name: "T1"
        id: t1
        debug: true
        x_position:
            id: t1_xpos
            name: t1_xpos
        y_position:
            id: t1_ypos
            name: t1_ypos
        speed:
            id: t1_speed
            name: t1_speed
        distance_resolution:
            id: t1_res
            name: t1_res
        angle:
            id: t1_angle
            name: t1_angle
        distance:
            id: t1_distance
            name: t1_distance
    - target:
        id: t2
        x_position:
            id: t2_xpos
            name: t2_xpos
        y_position:
            id: t2_ypos
            name: t2_ypos
        speed:
            id: t2_speed
            name: t2_speed
        distance_resolution:
            id: t2_res
            name: t2_res
        angle:
            id: t2_angle
            name: t2_angle
        distance:
            id: t2_distance
            name: t2_distance
    - target:
        id: t3
        x_position:
            id: t3_xpos
            name: t3_xpos
        y_position:
            id: t3_ypos
            name: t3_ypos
        speed:
            id: t3_speed
            name: t3_speed
        distance_resolution:
            id: t3_res
            name: t3_res
        angle:
            id: t3_angle
            name: t3_angle
        distance:
            id: t3_distance
            name: t3_distance
  zones:
`;
        config.zones.forEach((zone) => {
            if(zone.points.length < 3) return;
            const zId = zone.name.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
            
            yaml += `    - zone:
        name: "${zone.name}"
        margin: 25cm
        target_timeout: 5s
        polygon:
`;
            zone.points.forEach(p => {
                const m = pxToM(p.x, p.y);
                yaml += `          - point:
              x: ${m.x}m
              y: ${m.y}m
`;
            });
            
            yaml += `        occupancy:
          id: ${zId}_occupancy
          name: ${zId}_occupancy
        target_count:
          id: ${zId}_target_count
          name: ${zId}_target_count

`;
        });
        return yaml;
    }

    function generateCard() {
        const dev = config.name.replace(/-/g, '_');
        
        let yaml = `type: custom:plotly-graph
title: ${config.friendly} Map
refresh_interval: 1
hours_to_show: 0.01
config:
  displayModeBar: false
layout:
  height: 400
  margin: { l: 50, r: 50, t: 50, b: 70 }
  showlegend: true
  dragmode: false
  xaxis:
    title: 
      text: "Links / Rechts (cm)"
      font: { size: 10 }
    range: [-300, 300]
    dtick: 100
    fixedrange: true
    gridcolor: 'rgba(0,0,0,0.1)'
    zerolinecolor: 'rgba(0,0,0,0.1)'
  yaxis:
    title: 
      text: "Entfernung (cm)"
      font: { size: 10 }
    range: [0, 600]
    dtick: 100
    fixedrange: true
    gridcolor: 'rgba(0,0,0,0.1)'
    zerolinecolor: 'rgba(0,0,0,0.1)'
entities:
`;
        const targets = [
            {n:"Target 1", c:"blue",  x:`sensor.${dev}_t1_t1_xpos`, y:`sensor.${dev}_t1_t1_ypos`},
            {n:"Target 2", c:"red",   x:`sensor.${dev}_target_2_t2_xpos`, y:`sensor.${dev}_target_2_t2_ypos`},
            {n:"Target 3", c:"green", x:`sensor.${dev}_target_3_t3_xpos`, y:`sensor.${dev}_target_3_t3_ypos`}
        ];

        targets.forEach(t => {
            yaml += `  - entity: ""
    name: ${t.n}
    mode: markers
    marker: { size: 18, color: ${t.c}, line: { color: white, width: 2 } }
    x:
      - >-
        $ex parseFloat(hass.states['${t.x}']?.state || 0) * 100
    y:
      - >-
        $ex parseFloat(hass.states['${t.y}']?.state || 0) * 100
`;
        });

        config.zones.forEach(zone => {
            if(zone.points.length < 3) return;
            const xArr = [], yArr = [];
            zone.points.forEach(p => { 
                const m = pxToM(p.x, p.y); 
                xArr.push(Math.round(m.x * 100)); 
                yArr.push(Math.round(m.y * 100)); 
            });
            xArr.push(xArr[0]); yArr.push(yArr[0]);
            
            yaml += `  - entity: ""
    name: "${zone.name}"
    mode: lines
    fill: toself
    fillcolor: ${hexToRgba(zone.color, 0.1)}
    line: { color: '${hexToRgba(zone.color, 0.4)}', width: 2 }
    x: [${xArr.join(', ')}]
    y: [${yArr.join(', ')}]
`;
        });
        
        yaml += `  - entity: ""
    name: Coverage
    mode: lines
    fill: tonexty
    fillcolor: rgba(168, 216, 234, 0.1)
    line: { color: 'rgba(0,0,0,0.1)', width: 1, dash: dot }
    x: [0, 520, 450, 400, 300, 200, 100, 0, -100, -200, -300, -400, -450, -520, 0]
    y: [0, 300, 396, 447, 519, 565, 591, 600, 591, 565, 519, 447, 396, 300, 0]
raw_plotly_config: true
`;
        return yaml;
    }

    function exportConfig() { const a = document.createElement('a'); a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config)); a.download = config.name + ".json"; a.click(); }
    function importConfig(input) { const f = input.files[0]; if(!f) return; const r = new FileReader(); r.onload = e => { try { config = JSON.parse(e.target.result); activeZoneIdx = 0; renderUI(); draw(); updateAll(); } catch(err) { alert("Err: " + err); } }; r.readAsText(f); input.value = ''; }
    function copyToClip(id) { document.getElementById(id).select(); document.execCommand("copy"); }
    function hexToRgba(hex, alpha) { let c; if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){ c= hex.substring(1).split(''); if(c.length== 3){ c= [c[0], c[0], c[1], c[1], c[2], c[2]]; } c= '0x'+c.join(''); return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')'; } return 'rgba(0,0,0,'+alpha+')'; }

    init();
</script>
</body>
</html>
